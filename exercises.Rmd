---
title: "Network analysis"
author: "Wlad Stroukov"
date: "13/10/2021"
output: html_document
---

# Refresher on R data structures
## Vectors
```{r}
v1 <- 1:5  
v2 <- 5:1
v3 <- c(3,1,5,4,2)
cor(v1,v3)


(v1>2) | (v2>0)   # | is the boolean OR, returns a vector.
(v1>2) & (v2>0)   # & is the boolean AND, returns a vector.
(v1>2) || (v2>0)  # || is the boolean OR, returns a single value
(v1>2) && (v2>0)  # && is the boolean AND, ditto

v3
length(v3) <- 10
v3

```

## Factors
```{r}

eye.col.v <- c("brown", "green", "brown", "blue", "blue", "blue")         #vector
eye.col.f <- factor(c("brown", "green", "brown", "blue", "blue", "blue")) #factor
eye.col.v
eye.col.f
levels(eye.col.f)
as.numeric(eye.col.f)
as.numeric(eye.col.v)
as.character(eye.col.f)  
```

## Matrices and Arrays
Matrix 2D vectors
Arrays >2D
```{r}
m <- 1:20 # 20 elements 
m
dim(m) <- c(5,4) # Dimensions set to 5 & 4, so m is now a 5x4 matrix
m

m <-  matrix(data=1:20, nrow=5, ncol=4)
m
m <- matrix(1:20,5,4)
m

m <- cbind(1:5, 5:1, 5:9) # column bind
m
m <- rbind(1:5, 5:1, 5:9) # row bind
m

m <- matrix(1:100,10,10)
m
m[2,3]
m[2,]
m[1:4,2]
m[-1:-3,] # all rows except 1st to 3rd one

m[1,] == m[1,]
m >3

m[m>3]

t(m)
mt <- t(m)
mt

m %*% mt # matrix multiplication
m*mt     # element-wise multiplication


a <- array(data=1:18, dim=c(3,3,2))
a
```
## Lists
```{r}
l1 <-  list(boo=v1,foo=v2,moo=v3,zoo="Animals!") 
l2 <- list(v1,v2,v3,"Animals!")

l3 <- list()
l4 <- NULL

l1["zoo"] # returns a list
l1[["zoo"]] # returns the numeric element in the list (e.g. numeric vector, character, etc)
l1[1]    # 1st element
l1[[1]]
l1$boo   # $ operator is equivalent to [[]]

l3[[1]] <- 11
l3

l4[[3]] <- c(22,23) # coerces empty object into list and adds an element. unassigned elements will be generated and empty (NULL)

l1[[5]] <- "more elements"
l1[[8]] <- 1:5
l1

l1$something <- "A thing"
l1
names(l1) <- c("a","b","c","d","e","f","g","h","i")
l1
```
## DataFrames
```{r}
df1 <- data.frame(ID=1:4,
                  FirstName=c("John", "Jim", "Jane","Jill"),
                  Female=c(F,F,T,T),
                  Age=c(22,33,44,55),
                  stringsAsFactors = T)

df1["FirstName"] # get column
df1$FirstName
df1[["FirstName"]]

df1$FirstName <-  as.vector(df1$FirstName)


df1[1,]
df1[,1]
df1[1:2,3:4]

df1[df1$Age >30 ,2] # names of everyone over 30

mean(df1[df1$Female==T,4]) # Mean age of female entries


```
## Flow control
```{r}
x <- 5; y <- 10
if (x==0) y <- 0 else y <- y/x
y



ASum <- 0; AProd <- 1
for (i in 1:x)
{
  ASum <- ASum +1
  AProd <- AProd * i
}
ASum
AProd
prod(1:x)



x <- 5
while(x > 0){
  print(x)
  x <- x-1
  }



x <-0
repeat{
  print(x) 
  x <- x+1 
  if(x>10) break
}

```
# Networks
```{r}
rm(list=ls())
library(igraph)
```

## Create networks
```{r}
g1 <- graph(edges=c(1,2, 2,3, 3,1), directed=F) # undirected graph with 3 edges. Numbers are interpreted as Vertex IDs: 1->2, 2->3, 3->1
plot(g1)
# class(g1)
# g1
```



```{r}
g2 <- graph(edges=c(1,2, 2,3, 3,1), n=10) # 10 vertices
plot(g2)
# g2
```

```{r}
g3 <- graph(c("John","Jim", "Jim","Jill", "Jill","John", "John","Jill")) # with named vertices the argument "n" appears to be ignored. 
plot(g3)
```
The edge.curved argument of the `plot()` function adds a curve to the edge, but can mask edges due to overlay. There are supposed to be 2 edges from Jim to Jack.
```{r}
g4 <- graph(c("John", "Jim", "Jim", "Jack", "Jim", "Jack", "John", "John"),
            isolates=c("Jesse","Janis","Jennifer", "Justin"))
g4
#plot(g4)
plot(g4, edge.arrow.size=.5, vertex.color="gold", vertex.size=15,
     vertex.frame.color="gray", vertex.label.color="black",
     vertex.label.cex=0.8, vertex.label.dist=2, edge.curved=0.5) 


```
As in the example above, in most R functions, you can use named colors, hex, or rgb values. For example: “blue” “dark red” “#557799” or rgb(.25, .5, .3)) You can see the built-in colors name with `colors()`  

Small graphs can also be generated with a description of this kind: - for undirected tie, +- or -+
for directed ties pointing left & right, ++ for a symmetric tie, and “:” for sets of vertices.
```{r}
plot(graph_from_literal(a----b, b----c)) # the number of dashes doesn't matter
plot(graph_from_literal(a+b, b+c))
plot(graph_from_literal(a+-+b, b+-+c))
plot(graph_from_literal(a+-b, b+-c))


plot(graph_from_literal(a1:a2:a3--b1:b2:b3)) # sets of vertices with undirected edges
plot(graph_from_literal(a1:a2:a3--+b1:b2:b3, c--a1:a2:b3)) # it appears that all edges the either directed or undirected. Otherwise the undirected edges are ignored
plot(graph_from_literal(a1:a2:a3--+b1:b2:b3, c--+a1:a2:b3))

plot(graph_from_literal(a-b-c-d-e-f, a-g-h-b, h-e:f:i, j))
```
## Edge, vertex, and network attributes
```{r}
g4 <- graph(c("John", "Jim", "Jim", "Jack", "Jim", "Jack", "John", "John"),
            isolates=c("Jesse","Janis","Jennifer", "Justin"))
plot(g4)

```
```{r}
E(g4) # Edges
V(g4) # Vertices

g4[] # show as matrix
g4[1,]
```
Add attributes to the network, vertices, or edges:
```{r}
V(g4)$name # automatically generated when the network was created
```
examine attributes
```{r}
edge_attr(g4) # emtpy list
```
Assign new attributes to vertices and edges
```{r}
V(g4)$gender <- c("male","male","male","female","female","female", "male")
E(g4)$type <- "email" # Edge attribute "email" is assigned to all edges
E(g4)$weight <- 10    # Edge weight, setting all existing edges to 10
```

Check Edge attributes
```{r}
edge_attr(g4)
```
Check Vertex attributes
```{r}
vertex_attr(g4)
```
Check graph attributes (empty names list before adding attributes)
```{r}
graph_attr(g4)
```
Alternative way for adding attributes (set_edge_attr(), set_vertex_attr(), etc. )
```{r}
g4 <- set_graph_attr(g4, "name", "Email Network")
g4 <- set_graph_attr(g4, "something", "A thing")
graph_attr_names(g4)
```
Get individual graph attributes
```{r}
graph_attr(g4, "something")
graph_attr(g4)
```
```{r}
g4 <- delete_graph_attr(g4, "something")
graph_attr(g4)
```
Plot and color vertices by gender
```{r}
#c( "pink", "skyblue")[1+(V(g4)$gender=="male")] # how to select color
plot(g4, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
     vertex.color=c( "pink", "skyblue")[1+(V(g4)$gender=="male")] )

```

The graph g4 has two edges going from Jim to Jack, and a loop from John to himself. We can simplify our graph to remove loops & multiple edges between the same nodes. Use edge.attr.comb to indicate how edge attributes are to be combined - possible options include sum, mean, prod (product), min, max, first/last (selects the first/last edge’s attribute). Option “ignore” says the attribute should be disregarded and dropped.
```{r}
g4s <- simplify(g4, remove.multiple = T, remove.loops = F, edge.attr.comb=c(weight="sum", type="ignore"))
g4s
plot(g4s, vertex.label.dist=1.5)
```
The description of an igraph object starts with up to four letters:  

  1. D or U, for a directed or undirected graph
  2. N for a named graph (where nodes have a name attribute)
  3. W for a weighted graph (where edges have a weight attribute)
  4. B for a bipartite (two-mode) graph (where nodes have a type attribute)

The two numbers that follow (7 5) refer to the number of nodes and edges in the graph. The description also lists node & edge attributes, for example:  

  * (g/c) - graph-level character attribute
  * (v/c) - vertex-level character attribute
  * (e/n) - edge-level numeric attribute

## Specific graphs and graph models
```{r}

```