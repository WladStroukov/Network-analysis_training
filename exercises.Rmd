---
title: "Network analysis"
author: "Wlad Stroukov"
date: "13/10/2021"
output: html_document
---

This tutorial was developed by Katherine Ognyanova, www.kateto.net  

# Introduction to network analysis

The full tutorial can be found [here](https://kateto.net/wp-content/uploads/2018/03/R%20for%20Networks%20Workshop%20-%20Ognyanova%20-%202018.pdf)


# Refresher on R data structures
## Vectors
```{r}
v1 <- 1:5  
v2 <- 5:1
v3 <- c(3,1,5,4,2)
cor(v1,v3)


(v1>2) | (v2>0)   # | is the boolean OR, returns a vector.
(v1>2) & (v2>0)   # & is the boolean AND, returns a vector.
(v1>2) || (v2>0)  # || is the boolean OR, returns a single value
(v1>2) && (v2>0)  # && is the boolean AND, ditto

v3
length(v3) <- 10
v3

```

## Factors
```{r}

eye.col.v <- c("brown", "green", "brown", "blue", "blue", "blue")         #vector
eye.col.f <- factor(c("brown", "green", "brown", "blue", "blue", "blue")) #factor
eye.col.v
eye.col.f
levels(eye.col.f)
as.numeric(eye.col.f)
as.numeric(eye.col.v)
as.character(eye.col.f)  
```

## Matrices and Arrays
Matrix 2D vectors
Arrays >2D
```{r}
m <- 1:20 # 20 elements 
m
dim(m) <- c(5,4) # Dimensions set to 5 & 4, so m is now a 5x4 matrix
m

m <-  matrix(data=1:20, nrow=5, ncol=4)
m
m <- matrix(1:20,5,4)
m

m <- cbind(1:5, 5:1, 5:9) # column bind
m
m <- rbind(1:5, 5:1, 5:9) # row bind
m

m <- matrix(1:100,10,10)
m
m[2,3]
m[2,]
m[1:4,2]
m[-1:-3,] # all rows except 1st to 3rd one

m[1,] == m[1,]
m >3

m[m>3]

t(m)
mt <- t(m)
mt

m %*% mt # matrix multiplication
m*mt     # element-wise multiplication


a <- array(data=1:18, dim=c(3,3,2))
a
```
## Lists
```{r}
l1 <-  list(boo=v1,foo=v2,moo=v3,zoo="Animals!") 
l2 <- list(v1,v2,v3,"Animals!")

l3 <- list()
l4 <- NULL

l1["zoo"] # returns a list
l1[["zoo"]] # returns the numeric element in the list (e.g. numeric vector, character, etc)
l1[1]    # 1st element
l1[[1]]
l1$boo   # $ operator is equivalent to [[]]

l3[[1]] <- 11
l3

l4[[3]] <- c(22,23) # coerces empty object into list and adds an element. unassigned elements will be generated and empty (NULL)

l1[[5]] <- "more elements"
l1[[8]] <- 1:5
l1

l1$something <- "A thing"
l1
names(l1) <- c("a","b","c","d","e","f","g","h","i")
l1
```
## DataFrames
```{r}
df1 <- data.frame(ID=1:4,
                  FirstName=c("John", "Jim", "Jane","Jill"),
                  Female=c(F,F,T,T),
                  Age=c(22,33,44,55),
                  stringsAsFactors = T)

df1["FirstName"] # get column
df1$FirstName
df1[["FirstName"]]

df1$FirstName <-  as.vector(df1$FirstName)


df1[1,]
df1[,1]
df1[1:2,3:4]

df1[df1$Age >30 ,2] # names of everyone over 30

mean(df1[df1$Female==T,4]) # Mean age of female entries


```
## Flow control
```{r}
x <- 5; y <- 10
if (x==0) y <- 0 else y <- y/x
y



ASum <- 0; AProd <- 1
for (i in 1:x)
{
  ASum <- ASum +1
  AProd <- AProd * i
}
ASum
AProd
prod(1:x)



x <- 5
while(x > 0){
  print(x)
  x <- x-1
  }



x <-0
repeat{
  print(x) 
  x <- x+1 
  if(x>10) break
}

```
# Networks
```{r}
rm(list=ls())
library(igraph)
```

## Create networks
```{r}
g1 <- graph(edges=c(1,2, 2,3, 3,1), directed=F) # undirected graph with 3 edges. Numbers are interpreted as Vertex IDs: 1->2, 2->3, 3->1
plot(g1)
# class(g1)
# g1
```



```{r}
g2 <- graph(edges=c(1,2, 2,3, 3,1), n=10) # 10 vertices
plot(g2)
# g2
```

```{r}
g3 <- graph(c("John","Jim", "Jim","Jill", "Jill","John", "John","Jill")) # with named vertices the argument "n" appears to be ignored. 
plot(g3)
```
The edge.curved argument of the `plot()` function adds a curve to the edge, but can mask edges due to overlay. There are supposed to be 2 edges from Jim to Jack.
```{r}
g4 <- graph(c("John", "Jim", "Jim", "Jack", "Jim", "Jack", "John", "John"),
            isolates=c("Jesse","Janis","Jennifer", "Justin"))
g4
#plot(g4)
plot(g4, edge.arrow.size=.5, vertex.color="gold", vertex.size=15,
     vertex.frame.color="gray", vertex.label.color="black",
     vertex.label.cex=0.8, vertex.label.dist=2, edge.curved=0.5) 


```
As in the example above, in most R functions, you can use named colors, hex, or rgb values. For example: “blue” “dark red” “#557799” or rgb(.25, .5, .3)) You can see the built-in colors name with `colors()`  

Small graphs can also be generated with a description of this kind: - for undirected tie, +- or -+
for directed ties pointing left & right, ++ for a symmetric tie, and “:” for sets of vertices.
```{r}
plot(graph_from_literal(a----b, b----c)) # the number of dashes doesn't matter
plot(graph_from_literal(a+b, b+c))
plot(graph_from_literal(a+-+b, b+-+c))
plot(graph_from_literal(a+-b, b+-c))


plot(graph_from_literal(a1:a2:a3--b1:b2:b3)) # sets of vertices with undirected edges
plot(graph_from_literal(a1:a2:a3--+b1:b2:b3, c--a1:a2:b3)) # it appears that all edges the either directed or undirected. Otherwise the undirected edges are ignored
plot(graph_from_literal(a1:a2:a3--+b1:b2:b3, c--+a1:a2:b3))

plot(graph_from_literal(a-b-c-d-e-f, a-g-h-b, h-e:f:i, j))
```
## Edge, vertex, and network attributes
```{r}
g4 <- graph(c("John", "Jim", "Jim", "Jack", "Jim", "Jack", "John", "John"),
            isolates=c("Jesse","Janis","Jennifer", "Justin"))
plot(g4)

```
```{r}
E(g4) # Edges
V(g4) # Vertices

g4[] # show as matrix
g4[1,]
```
Add attributes to the network, vertices, or edges:
```{r}
V(g4)$name # automatically generated when the network was created
```
examine attributes
```{r}
edge_attr(g4) # emtpy list
```
Assign new attributes to vertices and edges
```{r}
V(g4)$gender <- c("male","male","male","female","female","female", "male")
E(g4)$type <- "email" # Edge attribute "email" is assigned to all edges
E(g4)$weight <- 10    # Edge weight, setting all existing edges to 10
```

Check Edge attributes
```{r}
edge_attr(g4)
```
Check Vertex attributes
```{r}
vertex_attr(g4)
```
Check graph attributes (empty names list before adding attributes)
```{r}
graph_attr(g4)
```
Alternative way for adding attributes (set_edge_attr(), set_vertex_attr(), etc. )
```{r}
g4 <- set_graph_attr(g4, "name", "Email Network")
g4 <- set_graph_attr(g4, "something", "A thing")
graph_attr_names(g4)
```
Get individual graph attributes
```{r}
graph_attr(g4, "something")
graph_attr(g4)
```
```{r}
g4 <- delete_graph_attr(g4, "something")
graph_attr(g4)
```
Plot and color vertices by gender
```{r}
#c( "pink", "skyblue")[1+(V(g4)$gender=="male")] # how to select color
plot(g4, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
     vertex.color=c( "pink", "skyblue")[1+(V(g4)$gender=="male")] )

```

The graph g4 has two edges going from Jim to Jack, and a loop from John to himself. We can simplify our graph to remove loops & multiple edges between the same nodes. Use edge.attr.comb to indicate how edge attributes are to be combined - possible options include sum, mean, prod (product), min, max, first/last (selects the first/last edge’s attribute). Option “ignore” says the attribute should be disregarded and dropped.
```{r}
g4s <- simplify(g4, remove.multiple = T, remove.loops = F, edge.attr.comb=c(weight="sum", type="ignore"))
g4s
plot(g4s, vertex.label.dist=1.5)
```
The description of an igraph object starts with up to four letters:  

  1. D or U, for a directed or undirected graph
  2. N for a named graph (where nodes have a name attribute)
  3. W for a weighted graph (where edges have a weight attribute)
  4. B for a bipartite (two-mode) graph (where nodes have a type attribute)

The two numbers that follow (7 5) refer to the number of nodes and edges in the graph. The description also lists node & edge attributes, for example:  

  * (g/c) - graph-level character attribute
  * (v/c) - vertex-level character attribute
  * (e/n) - edge-level numeric attribute

## Specific graphs and graph models
**Simple graphs**
```{r}
#Empty graph
eg <- make_empty_graph(40)
plot(eg, vertex.size=10, vertex.label=NA)

#full graph
fg <- make_full_graph(40)
plot(fg, vertex.size=10, vertex.label=NA)

# star graph
st <- make_star(40)
plot(st, vertex.size=10, vertex.label=NA)

# Tree graph
tr <- make_tree(60, children =5, mode = "undirected")
plot(tr, vertex.size=10, vertex.label=NA)

# Ring graph
rn <- make_ring(40)
plot(rn, vertex.size=10, vertex.label=NA)

# Erdos-Renyi random graph
er <- sample_gnm(n=100, m=40) # n number of nodes; m number of edges
plot(er, vertex.size=5, vertex.label=NA)
```


**Watts-Strogatz small-world model**

Creates a lattice (with dim dimensions and size nodes across dimension) and rewires edges randomly with probability p. The neighborhood in which edges are connected is nei. You can allow loops and multiple edges.
```{r}
sw <- sample_smallworld(dim=2, size=10, nei=1, p=0.1)
plot(sw, vertex.size=10, vertex.label=NA)
plot(sw, vertex.size=6, vertex.label=NA, layout=layout_in_circle)
plot(sw, vertex.size=6, vertex.label=NA, layout=layout_as_tree)
```
**Barabasi-Albert preferential attachment model for scale-free graphs**  

n is number of nodes, power is the power of attachment (1 is linear); m is the number of edges added on each time step
```{r}
ba <- sample_pa(n=100, power=1, m=1, directed=F)
plot(ba, vertex.size=6, vertex.label=NA)
```

**Notable historical graphs**
```{r}
zach <- graph("Zachary") # Zachary carate club
plot(zach, vertex.size=6, vertex.label=NA)
```
**Rewiring a graph**
each_edge() is a rewiring method that changes the edge endpoints uniformly randomly with a probability prob.
```{r}
plot(rn, vertex.size=6, vertex.label=NA)
rn.rewired <- rewire(rn, each_edge(prob=0.1))
plot(rn.rewired, vertex.size=6, vertex.label=NA)
```
Rewire to connect vertices to other vertices at certain distance
```{r}
rn.neigh <- connect.neighborhood(rn, 5)
plot(rn.neigh, vertex.size=6, vertex.label=NA)
```
Combine graphs (disjoint union, assuming separate vertex sets): `%du%`
```{r}
plot(rn, vertex.size=10, vertex.label=NA)
plot(tr, vertex.size=10, vertex.label=NA)
plot(rn %du% tr, vertex.size=10, vertex.label=NA)

```

# Reading network data
In the following sections of the tutorial, we will work primarily with two small example data sets.
Both contain data about media organizations. One involves a network of hyperlinks and mentions among news sources. The second is a network of links between media venues and consumers. While the example data used here is small, many of the ideas behind the analyses and visualizations we will generate apply to medium and large-scale networks.

## Reading edgelist data
```{r}
nodes <- read.csv("./ruworkshop/Data_files/Dataset1-Media-Example-NODES.csv")
links <- read.csv("./ruworkshop/Data_files/Dataset1-Media-Example-EDGES.csv")
```

Examining data
```{r}
head(nodes)
head(links)

nrow(nodes); length(unique(nodes$id))

#links[,c("from","to")]
nrow(links); nrow(unique(links[,c("from","to")]))
```
Notice that there are more links than unique from-to combinations. That means we have cases in the data where there are multiple links between the same two nodes. We will collapse all links of the same type between the same two nodes by summing their weights, using aggregate() by “from”, “to”, & “type”. We don’t use simplify() here so as not to collapse different link types. E.g. s01 -> s02 appears twice, both time of the type hyperlink. `simplfy()` would collaps all duplicated connections irrespective of their type (possibly without summing their weights)
```{r}
links
#?aggregate # aggregate(x, by, FUN)
# aggregate weight column by from, to, and type columns using the sum function
links <- aggregate(links[,3], links[,-3], sum)
links
links <- links[order(links$from, links$to),] # reorder the table
colnames(links)[4] <- "weight"
links
rownames(links) <- NULL # doesn't appear to be necessary
links

```

## Reading matrix data
Two-mode or bipartite graphs have two different types of actors and links that go across, but not within each type. Our second media example is a network of that kind, examining links between news sources and their consumers.

```{r}
nodes2 <- read.csv("./ruworkshop/Data_files/Dataset2-Media-User-Example-NODES.csv", header = T, as.is = T)
links2 <- read.csv("./ruworkshop/Data_files/Dataset2-Media-User-Example-EDGES.csv", header = T, row.names=1)
```

Examine data
```{r}
head(nodes2)
tail(nodes2)

head(links2)
```

```{r}
links2 <- as.matrix(links2)
links2
dim(links2)
dim(nodes2)
```
## Creating igraph objects
We start by converting the raw data to an igraph network object. Here we use igraph’s `graph.data.frame` function, which takes two data frames: d and vertices.  

  * d describes the edges of the network. Its first two columns are the IDs of the source and the target node for each edge. The following columns are edge attributes (weight, type, label, or anything else).
  * vertices starts with a column of node IDs. Any following columns are interpreted as node attributes.

### Dataset 1
```{r}
net <- graph_from_data_frame(d=links, vertices=nodes, directed=T)
class(net)
net
```

```{r}
plot(net, edge.arrow.size=.4, vertex.label=NA)
```
Cleaning up the network
```{r}
net <- simplify(net, remove.multiple = F, remove.loops=T)
plot(net, edge.arrow.size=.4,vertex.label=NA)
```
You might notice that we could have used simplify to combine multiple edges by summing their weights with a command like `simplify(net, edge.attr.comb=list(weight="sum","ignore"))`. The problem is that this would also combine multiple edge types (in our data: “hyperlinks” and “mentions”).  

If you need them, you can extract an edge list or a matrix from igraph networks. In graph theory and computer science, an adjacency matrix (=connection matrix) is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph.
```{r}
as_edgelist(net, names=T)
as_adjacency_matrix(net, attr="weight")
#?as_adjacency_matrix
```

Or data frames describing nodes and edges:
```{r}
as_data_frame(net, what="edges")
as_data_frame(net, what="vertices")
```
### Dataset 2
As we have seen above, this time the edges of the network are in a matrix format. We can read those into a graph object using graph_from_incidence_matrix(). In igraph, bipartite networks have a node attribute called type that is FALSE (or 0) for vertices in one mode and TRUE (or 1) for those in the other mode.
```{r}
head(nodes2)
tail(nodes2)

#head(links2)
links2
```
```{r}
net2 <- graph_from_incidence_matrix(links2) # for bipartite networks
table(V(net2)$type) #here, nodes of type s are F (or 0) and nodes of type U are T (or 1)

```
To transform a one-mode network matrix into an igraph object, use instead `graph_from_adjacency_matrix()`.  
We can also easily generate bipartite projections for the two-mode network: (co-memberships are easy to calculate by multiplying the network matrix by its transposed matrix, or using igraph’s bipartite.projection() function).  
[Bipartite networks](https://en.wikipedia.org/wiki/Bipartite_network_projection) are a particular class of complex networks, whose nodes are divided into two sets X and Y, and only connections between two nodes in different sets are allowed. For the convenience of directly showing the relation structure among a particular set of nodes, bipartite networks are usually compressed by one-mode projection. This means that the ensuing network contains nodes of only either of the two sets, and two X (or, alternatively, Y) nodes are connected only if when they have at least one common neighboring Y (or, alternatively, X) node.
```{r}
net2.bp <- bipartite.projection(net2)
net2.bp
```

Projections can be calculated manually as well.
```{r}
as_incidence_matrix(net2)
t(as_incidence_matrix(net2))

as_incidence_matrix(net2) %*% t(as_incidence_matrix(net2)) # projection 1
t(as_incidence_matrix(net2)) %*% as_incidence_matrix(net2) # projection 2
```
**Projection 1**
```{r}
plot(net2.bp$proj1, vertex.label.color="black", vertex.label.dist=1,
     vertex.size=7, vertex.label=nodes2$media[!is.na(nodes2$media.type)])
```
**Projection 2**
```{r}
plot(net2.bp$proj2, vertex.label.color="black", vertex.label.dist=1, 
     vertex.size=7, vertex.label=nodes2$media[ is.na(nodes2$media.type)])
```


# Plotting network data

